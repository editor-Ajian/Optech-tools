This week’s newsletter announces the disclosure of a bandwidth-wasting attack affecting Bitcoin Core and related nodes, describes several improvements to the idea for transaction fee sponsorship, and summarizes a discussion about using live mempool data to improve Bitcoin Core’s feerate estimation. Also included are our regular sections with selected questions and answers from the Bitcoin Stack Exchange, announcements of new releases and release candidates, and notable changes to popular Bitcoin infrastructure projects.

## News

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#disclosure-of-free-relay-attack) **Disclosure of free relay attack:** a bandwidth-wasting attack was [described](https://gnusha.org/pi/bitcoindev/Zfg%2F6IZyA%2FiInyMx@petertodd.org/) to the Bitcoin-Dev mailing list. In short, Mallory broadcasts one version of a transaction to Alice and a different version of the transaction to Bob. The transactions are designed so that Bob won’t accept Alice’s version as an [RBF replacement](https://bitcoinops.org/en/topics/replace-by-fee/) and Alice won’t accept Bob’s version. Mallory then sends Alice a replacement that she will accept but Bob won’t. Alice relays the replacement to Bob, consuming their mutual bandwidth, but Bob rejects it, resulting in the relay bandwidth being wasted (called [free relay](https://bitcoinops.org/en/topics/free-relay/)). Mallory can repeat this multiple times until a transaction eventually gets confirmed, with each cycle seeing Alice accept the replacement, use bandwidth sending it to Bob, and Bob rejecting it. The effect of the attack can be multiplied by Alice having multiple Bob-like peers who all reject the replacements and Mallory sending multiple specially constructed transactions of this type in parallel.

  The attack is limited by the fee costs Mallory will pay when some version of her transactions eventually confirms, although the attack description notes that this can be essentially zero if Mallory was planning to send a transaction anyway. The maximum amount of bandwidth that can be wasted is limited by Bitcoin Core’s existing transaction relay limits, although it is possible that performing this attack many times in parallel could delay the propagation of legitimate unconfirmed transactions.

  The description also mentions another well-known type of node bandwidth wasting, where a user broadcasts a set of large transactions and then works with a miner to create a block that contains a relatively small transaction that conflicts with all the relayed transactions. For example, a 29,000-vbyte transaction could remove about 200 megabytes of transactions from every relaying full node’s mempool. The description argues that the existence of attacks that allow wasting bandwidth means that it should be reasonable to deliberately allow some amount of free relay, such as by enabling proposals like replace by feerate (see [Newsletter #288](https://bitcoinops.org/en/newsletters/2024/02/07/#proposal-for-replace-by-feerate-to-escape-pinning)). 

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#transaction-fee-sponsorship-improvements) **Transaction fee sponsorship improvements:** Martin Habovštiak [posted](https://gnusha.org/pi/bitcoindev/CALkkCJZWBTmWX_K0+ERTs2_r0w8nVK1uN44u-sz5Hbb-SbjVYw@mail.gmail.com/) to the Bitcoin-Dev mailing list an idea for allowing one transaction to boost the priority of an unrelated transaction. Fabian Jahr [noted](https://gnusha.org/pi/bitcoindev/45ghFIBR0JCc4INUWdZcZV6ibkcoofy4MoQP_rQnjcA4YYaznwtzSIP98QvIOjtcnIdRQRt3jCTB419zFa7ZNnorT8Xz--CH4ccFCDv9tv4=@protonmail.com/) that the fundamental idea appears to be very similar to [transaction fee sponsorship](https://bitcoinops.org/en/topics/fee-sponsorship/), which was proposed in 2020 by Jeremy Rubin (see [Newsletter #116](https://bitcoinops.org/en/newsletters/2020/09/23/#transaction-fee-sponsorship)). In Rubin’s original proposal, the *sponsor transaction* committed to the *boosted transactions* using a zero-value output script, which uses about 42 vbytes for a single sponsorship and about 32 bytes for each additional sponsorship. In Habovštiak’s version, the sponsor transaction commits to the boosted transaction using the taproot [annex](https://bitcoinops.org/en/topics/annex/), which uses about 8 vbytes for a single sponsorship and 8 vbytes for each additional sponsorship.

  After hearing about Habovštiak’s idea, David Harding [posted](https://delvingbitcoin.org/t/improving-transaction-sponsor-blockspace-efficiency/696) to Delving Bitcoin an efficiency improvement he and Rubin had previously developed in January. The sponsor transaction commits to the boosted transaction using the signature commitment message, which is never published onchain, so zero block space is used for a single commitment. To allow this, the sponsor transaction must appear in blocks and [package relay](https://bitcoinops.org/en/topics/package-relay/) messages immediately after the boosted transaction, allowing full node verifiers to infer the txid of the boosted transaction when they verify the sponsor transaction.

  For cases where a block may contain multiple sponsor transactions that each commit to some of the same boosted transactions, it’s not possible to simply have a series of boosted transactions appear immediately before their sponsors, so entirely inferable commitments is not an option. Harding describes a simple alternative that only uses 0.5 vbytes per boosted transaction; Anthony Towns [improves](https://delvingbitcoin.org/t/improving-transaction-sponsor-blockspace-efficiency/696/5) upon that with a version that would never use more than 0.5 vbytes per boost and would use less space in most cases.

  Both Habovštiak and Harding note the potential for outsourcing: anyone who is planning to broadcast a transaction anyway (or who has an unconfirmed transaction they’re willing to update with [RBF](https://bitcoinops.org/en/topics/replace-by-fee/)) can increase its feerate and boost another transaction at an insignificant cost of 0.5 vbytes or less per boost; for comparison, 0.5 vbytes is about 0.3% of a 1-input, 2-output P2TR transaction. Unfortunately, they both warn that there’s no convenient way to trustlessly pay a third party for a boost; however, Habovštiak points out that anyone paying over LN would receive [proof of payment](https://bitcoinops.org/en/topics/proof-of-payment/) and so could potentially prove deceit.

  Towns further notes that sponsors seems compatible with the proposed design for [cluster mempool](https://bitcoinops.org/en/topics/cluster-mempool/), that the most efficient versions of sponsorship present some mild challenges for transaction validity caching, and concludes with a table showing the relative block space consumed by various current and proposed fee bumping techniques. At 0.5 vbytes or less per boost, the most efficient form of fee sponsorship is only bested by the 0.0 vbytes used in the best case with RBF and paying miners [out-of-band](https://bitcoinops.org/en/topics/out-of-band-fees/). Because fee sponsorship allows dynamic fee bumping and is almost as efficient as paying miners out-of-band, it may resolve a major concern with protocols that depend on [exogenous fees](https://bitcoinops.org/en/topics/fee-sourcing/).

  In [continued discussion](https://delvingbitcoin.org/t/improving-transaction-sponsor-blockspace-efficiency/696/6) shortly before this newsletter was about to be published, Suhas Daftuar raised concerns that sponsors could introduce problems that are not easily addressed by cluster mempool and which could create problems for users who didn’t need sponsors, indicating that sponsorship (if it is ever added to Bitcoin) should only be available to transactions that opt-in to allowing it. 

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#mempool-based-feerate-estimation) **Mempool-based feerate estimation:** Abubakar Sadiq Ismail [posted](https://delvingbitcoin.org/t/mempool-based-fee-estimation-on-bitcoin-core/703) to Delving Bitcoin about improving Bitcoin Core’s [feerate estimation](https://bitcoinops.org/en/topics/fee-estimation/) using data from a node’s local mempool. Currently, Bitcoin Core generates estimates by recording the block height when each unconfirmed transaction is received, the block height when it is confirmed, and its feerate. When all of that information is known, the delta between received height and confirmed height is used to update an exponentially weighted moving average for a bucket that represents a range of feerates. For example, a transaction that takes 100 blocks to confirm with a feerate of 1.1 sat/vbyte will be incorporated into the average for the 1 sat/vbyte bucket.

  An advantage of this approach is its resistance to manipulation: all transactions must be both relayed (meaning they’re available to all miners) and confirmed (meaning they can’t violate any consensus rules). A disadvantage is that it only updates once per block and can lag far behind other estimates that use real-time mempool information.

  Ismail has taken [previous discussion](https://github.com/bitcoin/bitcoin/issues/27995) about incorporating mempool data into feerate estimates, written some preliminary code, and performed an analysis showing how the current algorithm and a new algorithm compare (not including some safety checks). A [reply](https://delvingbitcoin.org/t/mempool-based-fee-estimation-on-bitcoin-core/703/2) to the thread also linked to [previous research](https://scalingbitcoin.org/stanford2017/Day2/Scaling-2017-Optimizing-fee-estimation-via-the-mempool-state.pdf) on this topic by Kalle Alm and led to a discussion about whether mempool information should be used to both raise and lower feerate estimates, or if it should only be used to lower estimates. The advantage of doing both is that it overall makes the estimates more useful; the advantage of only lowering estimates using mempool data (while only raising estimates using the existing confirmation-based estimation) is that it could be more resistant to manipulation and positive feedback loops.

  Discussion was ongoing as of this writing. 

## Selected Q&A from Bitcoin Stack Exchange

*[Bitcoin Stack Exchange](https://bitcoin.stackexchange.com/) is one of the first places Optech contributors look for answers to their questions—or when we have a few spare moments to help curious or confused users. In this monthly feature, we highlight some of the top-voted questions and answers posted since our last update.*

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#what-are-the-risks-of-running-a-pre-segwit-node-0-12-1) [What are the risks of running a pre-SegWit node (0.12.1)?](https://bitcoin.stackexchange.com/a/122211) Michael Folkson, Vojtěch Strnad, and Murch list downsides to running Bitcoin Core 0.12.1 for an individual user including a higher risk of accepting an invalid transaction or block, increased vulnerability to double spend attacks, higher reliance on others to do updated consensus validation, much slower block validation, missing many performance improvements, inability to use [compact block relay](https://bitcoinops.org/en/topics/compact-block-relay/), not relaying ~95% of current unconfirmed transactions, less accurate [fee estimation](https://bitcoinops.org/en/topics/fee-estimation/), and vulnerability to security issues fixed in previous versions. Wallet users of 0.12.1 would also miss out on developments around [miniscript](https://bitcoinops.org/en/topics/miniscript/), [descriptor](https://bitcoinops.org/en/topics/output-script-descriptors/) wallets, and the fee savings and additional script capabilities enabled by [segwit](https://bitcoinops.org/en/topics/segregated-witness/), [taproot](https://bitcoinops.org/en/topics/taproot/), and [schnorr signatures](https://bitcoinops.org/en/topics/schnorr-signatures/). Effects on the Bitcoin network if Bitcoin Core 0.12.1 was more broadly adopted could include: higher chance of invalid blocks being accepted by the network and associated reorg risk, miner centralization pressure from increased stale block risk, and decreased mining rewards for miners running that version. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#when-is-op-return-cheaper-than-op-false-op-if) [When is OP_RETURN cheaper than OP_FALSE OP_IF?](https://bitcoin.stackexchange.com/a/122321) Vojtěch Strnad details the overheads associated with `OP_RETURN`-based data embedding and `OP_FALSE` `OP_IF`-based embedding, concluding that “`OP_RETURN` is cheaper for data smaller than 143 bytes”. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#why-does-bip-340-use-secp256k1) [Why does BIP-340 use secp256k1?](https://bitcoin.stackexchange.com/a/122268) Pieter Wuille explains the rationale of choosing secp256k1 over Ed25519 for [BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) schnorr signatures and notes “reusability of existing key derivation infrastructure” and “not changing security assumptions” as reasons for the choice. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#what-criteria-does-bitcoin-core-use-to-create-block-templates) [What criteria does Bitcoin Core use to create block templates?](https://bitcoin.stackexchange.com/a/122216) Murch explains Bitcoin Core’s current ancestor set feerate-based algorithm for transaction selection for a block candidate and mentions ongoing work on [cluster mempool](https://bitcoinops.org/en/topics/cluster-mempool/) which offers various improvements. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#how-does-the-initialblockdownload-field-in-the-getblockchaininfo-rpc-work) [How does the initialblockdownload field in the getblockchaininfo RPC work?](https://bitcoin.stackexchange.com/a/122169) Pieter Wuille notes the two conditions that need to occur after node startup for `initialblockdownload` to become false:
  1. “The currently active chain has at least as much cumulative PoW as the hardcoded constant in the software”
  2. “The timestamp of the currently active tip is no more than 24 hours in the past”



## Releases and release candidates

*New releases and release candidates for popular Bitcoin infrastructure projects. Please consider upgrading to new releases or helping to test release candidates.*

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#bitcoin-core-26-1rc2) [Bitcoin Core 26.1rc2](https://bitcoincore.org/bin/bitcoin-core-26.1/) is a release candidate for a maintenance release of the network’s predominant full node implementation. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#bitcoin-core-27-0rc1) [Bitcoin Core 27.0rc1](https://bitcoincore.org/bin/bitcoin-core-27.0/test.rc1/) is a release candidate for the next major version of the network’s predominant full node implementation. There’s a brief overview to [suggested testing topics](https://github.com/bitcoin-core/bitcoin-devwiki/wiki/27.0-Release-Candidate-Testing-Guide) and a scheduled meeting of the [Bitcoin Core PR Review Club](https://bitcoincore.reviews/) dedicated to testing today (March 27th) at 15:00 UTC. 

## Notable code and documentation changes

*Notable recent changes in [Bitcoin Core](https://github.com/bitcoin/bitcoin), [Core Lightning](https://github.com/ElementsProject/lightning), [Eclair](https://github.com/ACINQ/eclair), [LDK](https://github.com/lightningdevkit/rust-lightning), [LND](https://github.com/lightningnetwork/lnd/), [libsecp256k1](https://github.com/bitcoin-core/secp256k1), [Hardware Wallet Interface (HWI)](https://github.com/bitcoin-core/HWI), [Rust Bitcoin](https://github.com/rust-bitcoin/rust-bitcoin), [BTCPay Server](https://github.com/btcpayserver/btcpayserver/), [BDK](https://github.com/bitcoindevkit/bdk), [Bitcoin Improvement Proposals (BIPs)](https://github.com/bitcoin/bips/), [Lightning BOLTs](https://github.com/lightning/bolts), [Bitcoin Inquisition](https://github.com/bitcoin-inquisition/bitcoin), and [BINANAs](https://github.com/bitcoin-inquisition/binana).*

*Note: the commits to Bitcoin Core mentioned below apply to its master development branch and so those changes will likely not be released until about six months after the release of the upcoming version 27.*

- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#bitcoin-core-28950) [Bitcoin Core #28950](https://github.com/bitcoin/bitcoin/issues/28950) updates the `submitpackage` RPC with arguments for `maxfeerate` and `maxburnamount` which will terminate the call in failure if the provided package has an aggregate feerate above the indicated maximum or sends more than the indicated amount to a well-known template for an unspendable output. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#lnd-8418) [LND #8418](https://github.com/lightningnetwork/lnd/issues/8418) begins polling its connected Bitcoin protocol client for its full node peers’ [BIP133](https://github.com/bitcoin/bips/blob/master/bip-0133.mediawiki) `feefilter` values. The `feefilter` message allows a node to tell its connected peers the lowest feerate it’ll accept for a transaction to relay. LND will now use this information to avoid sending transactions with too low of a feerate. Only `feefilter` values from outbound peers are used, as those are the peers the user’s node chose to connect to and so they are less likely to be controlled by attackers than inbound peers that requested a connection. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#ldk-2756) [LDK #2756](https://github.com/lightningdevkit/rust-lightning/issues/2756) adds support for including a [trampoline routing](https://bitcoinops.org/en/topics/trampoline-payments/) packet in its messages. This doesn’t provide full support for using trampoline routing or providing trampoline routing services, but it does make it easier for other code to accomplish that using LDK. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#ldk-2935) [LDK #2935](https://github.com/lightningdevkit/rust-lightning/issues/2935) begins supporting sending [keysend payments](https://bitcoinops.org/en/topics/spontaneous-payments/) to [blinded paths](https://bitcoinops.org/en/topics/rendez-vous-routing/). Keysend payments are unconditional payments sent without an invoice. Blinded paths hide the final hops of the payment path from the spender. Blinded paths are usually encoded in an invoice, so they’re usually not combined with keysend payments, but they can make sense when a Lightning service provider (LSP) or some other node wants to provide a generic invoice for a particular receiver without revealing the receiver’s node ID. 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#ldk-2419) [LDK #2419](https://github.com/lightningdevkit/rust-lightning/issues/2419) adds a state machine for handling [interactive transaction construction](https://bitcoinops.org/en/topics/dual-funding/), a dependency for dual-funded channels and [splicing](https://bitcoinops.org/en/topics/splicing/). 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#rust-bitcoin-2549) [Rust Bitcoin #2549](https://github.com/rust-bitcoin/rust-bitcoin/issues/2549) makes various changes to the APIs for working with relative [locktimes](https://bitcoinops.org/en/topics/timelocks/). 
- [●](https://bitcoinops.org/en/newsletters/2024/03/27/#btcpay-server-5852) [BTCPay Server #5852](https://github.com/btcpayserver/btcpayserver/issues/5852) adds support for scanning BBQr animated QR codes (see [Newsletter #281](https://bitcoinops.org/en/newsletters/2023/12/13/#bbqr-encoding-scheme-announced)) for [PSBTs](https://bitcoinops.org/en/topics/psbt/). 



